# -*- coding: utf-8 -*-
"""sistemas_lineales_ComunidadCarlitos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ONnm_nyG87KKbZ8MGEYTQ4emkE4rtsWr
"""

################### Script creado por Comunidad Carlitos ##########################
###################################################################################


############################# CODIGO ##############################################

############################ librerias ############################################

## Importar los modulos especificos de las librerías para ahorrar espacio de la RAM 
from numpy import zeros, matrix, seterr
from numpy.linalg import det, solve
seterr(divide='ignore', invalid='ignore', over="ignore", under="ignore") # evitar mensajes de warning por calculos

## Funcion de aproximación para el metodo de Gauss-Seidel

def aproximacion(x,A,B):
  ap = zeros((n,1)) # matriz que guardara los valores calculados 
  for i in range(n):
    ap[i] = B[i]
    for j in range(n):
      if j > i:
        ap[i] -= x[j]*A[i][j]
      if j < i:
        ap[i] -= ap[j]*A[i][j] ## diferencia al metodo de Jacobi
    ap[i] /= A[i][i]
  return ap

################################ Programa ########################################

while True:
  print("""
Bienvenido

En este programa se calcula la solución de un sistema lineal.
En primer lugar se debe ingresar los valores de cada ecuación
ingresando por cada ecuación los coeficientes de cada variable 
y los coeficientes independientes. Posteriormente se elige el
metodo que se desea usar para el cálculo.

Ingrese un 0 y presione enter si desea salir del programa o presione solo enter para continuar""")
  
  sel = input()
  if sel == "0": # terminar programa
    break

  print("""

A continuación ingrese los coeficientes de cada uno de las variables de cada ecuación en orden. Para esto,
ingrese cada coeficiente separado de un espacio, cuando acabe de digitar los coeficientes de una ecuación
(OJO solo aquellos que acompañan a las variables) agregue punto y coma (;) para continuar con la siguiente 
ecuacion. Al terminar de añadir la matriz presione enter.

""")
################################# Ingreso coeficientes ##########################################
  
## Matriz A de coeficientes dependientes
  
  while True:
    A0 = input()
    A1 = matrix(A0) ## convierte el string en una matriz 
    A = A1.A ## convierte la matriz a un arreglo para mejor manipulación
    n = len(A) ## dimension de la matriz o cantidad de variables
    shapeA = "("+str(n)+", "+str(n)+")"
    if str(A.shape) != shapeA: ## si la matriz no es cuadrada
      print("La matriz no es cuadrada y no es posible solucionarla mediante este codigo, ingrese una nueva matriz")
    else:
      break
  
  print("""

Ahora ingrese los valores independientes (aquellos que no multiplican alguna variable en cada ecuación) separados
por punto y coma (;)

""")
  
## Matriz B de coeficientes independientes  

  while True:
    B0 = input()
    B1 = matrix(B0)
    shapeB = "("+str(n)+", 1)"
    if str(B1.shape) != shapeB: ## si no se tiene la misma cantidad de ecuaciones que de coeficientes
      print("La matriz no tiene la cantidad de terminos equivalente a la cantidad de ecuaciones, por favor ingrese correctamente los datos")
    else:
      break
  B = B1.A 

## Rectificación de diagonalmente dominante
  
  cont = 0
  for i in range(n):
    suma = 0
    for j in range(n):
      if j != i:
        suma += abs(A[i][j])
    if abs(A[i][i]) > suma: 
      cont += 1

  if cont == n:
    print("""

La matriz usada es una matriz diagonalmente dominante,
por lo tanto se asegura su convergencia por el metodo 
de Gauss-Seidel.

""")    
  else:
    print("""

La matriz usada no es una matriz diagonalmente dominante,
por lo tanto no se asegura su convergencia por el metodo 
de Gauss-Seidel, queda a su criterio utilizarla.

""") 
  
################################ Menú ######################################## 

  while True: # ciclo del menú
    while True: # ciclo para ingreso correcto de la selección del menú
      selec = str(input("""

Si desea usar el metodo directo a partir de la relación Ax = B, digite 1.
Si desea usar el metodo iterativo de Gauss-Seidel, digite 2.
Si desea volver al inicio, digite 0.
    
  """))
      if selec == "0" or selec == "1" or selec == "2":
        break
      else:
        print("""
        
Por favor ingrese un valor correcto
        
        """)

    if selec == "0":
      break
    if selec == "1":

############### Metodo Directo Ax = B ########################

      if det(A) == 0: ## verifica si la matriz es invertible
        print("""

No se puede resolver mediante el metodo de la inversa""")
      else:
        C = solve(A,B) ## metodo de Gauss con la libreria
        sol="\n\n"+"la solucion es: "+"\n"
        for i in range(n): ## impresion de datos
          xr1 = str(C[i]).replace("[","") ## eliminar corchetes innecesarios
          xr2 = xr1.replace("]","")
          sol+="x"+str(i+1)+" = "+xr2+"\n"
        print(sol)
    
    if selec == "2":

################ Metodo de Gauss-Seidel ######################

    ## ingreso de datos

      xl = zeros((n,1)) ## semilla
      print("""
a continuación ingrese la semilla que desea utilizar de la misma 
forma que ingreso la matriz de coeficientes independientes""")
      
      while True: # ciclo para ingreso de la semilla
        l0 = input()
        l1 = matrix(B0)
        shapel = "("+str(n)+", 1)"
        if str(l1.shape) != shapel:
          print("La matriz no tiene la cantidad de terminos equivalente a la cantidad de incognitas, por favor ingrese correctamente los datos")
        else:
          break
      xl = l1.A

      while True: # ciclo para ingreso de las cifras significativas
            print("ingrese las cifras significativas que desea para cada una de las soluciones: ")
            cs0 = int(input())
            try:
              cs = int(cs0)
              if cs > 0:
                break
              else:
                print("ingrese un valor mayor a 0")
            except:
              print("ingrese un numero valido")

      Es = 0.5*(10**(2-cs)) # error de referencia
      tol = 1000 # maxima cantidad de iteraciones
      xf = xl
      it = 0 # iteraciones del metodo

      ## inicio iteraciones
      
      while True:
        it += 1
        xi = xf
        xf = aproximacion(xi,A,B) # se aplica la aproximación
        Ea = abs((xi-xf)/xf)*100 # calculo del error aproximado
        if it == tol: # Condicion de paro: Limite maximo de iteraciones totales
          sol = "\n\n"+"no se encontro ninguna solución dentro de las cifras significativas requeridas luego de 1000 iteraciones"
          break
        j = 0 # contador para los valores que cumplen con el error de referencia
        for i in range(n):
          if Ea[i] < Es:
            j += 1
        if j == n: # Condicion de paro: error aproximado dentro del error de referencia en todas las variables
          sol = "\n\n"
          for i in range(n):
            xr1 = str(xf[i]).replace("[","") # se vuelven a eliminar los corchetes
            xr2 = xr1.replace("]","")
            sol += "el valor aproximado de x"+str(i+1)+" es "+xr2+" con un error de "+str(Ea[i])+"\n"
          sol += "\nla solución se obtuvo luego de "+str(it)+" iteraciones"
          break
      print(sol)